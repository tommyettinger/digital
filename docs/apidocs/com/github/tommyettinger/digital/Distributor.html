<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (21) -->
<title>Distributor (digital 0.7.0 API)</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="description" content="declaration: package: com.github.tommyettinger.digital, class: Distributor">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../script-dir/jquery-ui.min.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
<script type="text/javascript" src="../../../../script-dir/jquery-3.6.1.min.js"></script>
<script type="text/javascript" src="../../../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var pathtoroot = "../../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar-top"><button id="navbar-toggle-button" aria-controls="navbar-top" aria-expanded="false" aria-label="Toggle navigation links"><span class="nav-bar-toggle-icon">&nbsp;</span><span class="nav-bar-toggle-icon">&nbsp;</span><span class="nav-bar-toggle-icon">&nbsp;</span></button>
<div class="skip-nav"><a href="#skip-navbar-top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar-top-firstrow" class="nav-list" title="Navigation">
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html#class">Help</a></li>
</ul>
<ul class="sub-nav-list-small">
<li>
<p>Summary:</p>
<ul>
<li>Nested</li>
<li>Field</li>
<li>Constr</li>
<li><a href="#method-summary">Method</a></li>
</ul>
</li>
<li>
<p>Detail:</p>
<ul>
<li>Field</li>
<li>Constr</li>
<li><a href="#method-detail">Method</a></li>
</ul>
</li>
</ul>
</div>
<div class="sub-nav">
<div id="navbar-sub-list">
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method-summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method-detail">Method</a></li>
</ul>
</div>
<div class="nav-list-search"><a href="../../../../search.html">SEARCH</a>
<input type="text" id="search-input" disabled placeholder="Search">
<input type="reset" id="reset-button" disabled value="reset">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip-navbar-top"></span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">com.github.tommyettinger.digital</a></div>
<h1 title="Class Distributor" class="title">Class Distributor</h1>
</div>
<div class="inheritance" title="Inheritance Tree"><a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">java.lang.Object</a>
<div class="inheritance">com.github.tommyettinger.digital.Distributor</div>
</div>
<section class="class-description" id="class-description">
<hr>
<div class="type-signature"><span class="modifiers">public final class </span><span class="element-name type-name-label">Distributor</span>
<span class="extends-implements">extends <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></span></div>
<div class="block">Different methods for distributing input <code>long</code> or <code>double</code> values from a given domain into specific
 distributions, such as the normal distribution. <a href="#probit(double)"><code>probit(double)</code></a> and <a href="#probitHighPrecision(double)"><code>probitHighPrecision(double)</code></a> take
 a double in the 0.0 to 1.0 range (typically exclusive, but not required to be), and produce a normal-distributed
 double centered on 0.0 with standard deviation 1.0, using an algorithm by Acklam. The suffixed
 <a href="#probitD(double)"><code>probitD(double)</code></a>, <a href="#probitF(float)"><code>probitF(float)</code></a>, <a href="#probitL(long)"><code>probitL(long)</code></a>, and <a href="#probitI(int)"><code>probitI(int)</code></a> use a faster but
 still fairly-high-quality approximation by Voutier, and are usually indistinguishable from the earlier
 <a href="#probit(double)"><code>probit(double)</code></a>. The float and double versions also take inputs in the 0.0 to 1.0 range, but the int and long
 versions can take any int or any long, with the lowest values mapping to the lowest results, highest to highest, near
 0 to near 0, etc. Using the suffixed probit() methods, such as <a href="#probitF(float)"><code>probitF(float)</code></a>, is recommended when
 generating normal-distributed floats or doubles.
 <br>
 All of these ways will preserve patterns in the input, so inputs close to the lowest
 possible input (0.0 for probit(), <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Long.html#MIN_VALUE" title="class or interface in java.lang" class="external-link"><code>Long.MIN_VALUE</code></a> for normal(), <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Integer.html#MIN_VALUE" title="class or interface in java.lang" class="external-link"><code>Integer.MIN_VALUE</code></a> for normalF()) will
 produce the lowest possible output (-8.375 for probit(), -26.48372928592822 for probitD() and probitL(), or -9.082295
 for probitF() and probitI()),
 and similarly for the highest possible inputs producing the highest possible outputs.
 <br>
 There's also <a href="#normal(long)"><code>normal(long)</code></a> and <a href="#normalF(int)"><code>normalF(int)</code></a>, which use the
 <a href="https://en.wikipedia.org/wiki/Ziggurat_algorithm">Ziggurat method</a> and do not preserve input patterns.
 The Ziggurat method does get closer to the correct normal distribution in the trail (where very positive
 or very negative values are) relative to probit methods. Surprisingly, <a href="#probitF(float)"><code>probitF(float)</code></a> is a little faster
 than <a href="#normalF(int)"><code>normalF(int)</code></a>, even considering that generating random floats for input is slower than generating random
 ints. However, <a href="#normal(long)"><code>normal(long)</code></a> is somewhat faster than <a href="#probitL(long)"><code>probitL(long)</code></a>.
 <br>
 This class also still contains some older methods, for compatibility with earlier versions of this library. The
 "Linnormal" methods <a href="#linearNormal(long)"><code>linearNormal(long)</code></a> and <a href="#linearNormalF(int)"><code>linearNormalF(int)</code></a> are like <a href="#probitL(long)"><code>probitL(long)</code></a>,
 though they used an algorithm that approximated the normal distribution very poorly. They are currently aliases for
 <a href="#probitL(long)"><code>probitL(long)</code></a> and <a href="#probitI(int)"><code>probitI(int)</code></a>.</div>
</section>
<section class="summary">
<ul class="summary-list">
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method-summary">
<h2>Method Summary</h2>
<div id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button id="method-summary-table-tab0" role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table', 3)" class="active-table-tab">All Methods</button><button id="method-summary-table-tab1" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab1', 3)" class="table-tab">Static Methods</button><button id="method-summary-table-tab4" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab4', 3)" class="table-tab">Concrete Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel" aria-labelledby="method-summary-table-tab0">
<div class="summary-table three-column-summary">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Method</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#linearNormal(long)" class="member-name-link">linearNormal</a><wbr>(long&nbsp;n)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">This is an alias for <a href="#probitL(long)"><code>probitL(long)</code></a>; see its docs for details.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#linearNormalF(int)" class="member-name-link">linearNormalF</a><wbr>(int&nbsp;n)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">This is an alias for <a href="#probitI(int)"><code>probitI(int)</code></a>; see its docs for details.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#normal(long)" class="member-name-link">normal</a><wbr>(long&nbsp;state)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Given a long where all bits are sufficiently (independently) random, this produces a normal-distributed
 (Gaussian) variable as if by a normal distribution with mean (mu) 0.0 and standard deviation (sigma) 1.0.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#normalF(int)" class="member-name-link">normalF</a><wbr>(int&nbsp;state)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Given an int where all bits are sufficiently (independently) random, this produces a normal-distributed float
 (Gaussian) variable as if by a normal distribution with mean (mu) 0.0 and standard deviation (sigma) 1.0.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#probit(double)" class="member-name-link">probit</a><wbr>(double&nbsp;d)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">A way of taking a double in the (0.0, 1.0) range and mapping it to a Gaussian or normal distribution, so high
 inputs correspond to high outputs, and similarly for the low range.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#probitD(double)" class="member-name-link">probitD</a><wbr>(double&nbsp;p)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">A double-precision probit() approximation that takes a double between 0 and 1 inclusive and returns an
 approximately-Gaussian-distributed double between -26.48372928592822 and 26.48372928592822 .</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#probitF(float)" class="member-name-link">probitF</a><wbr>(float&nbsp;p)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">A single-precision probit() approximation that takes a float between 0 and 1 inclusive and returns an
 approximately-Gaussian-distributed float between -9.082295 and 9.082295 .</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#probitHighPrecision(double)" class="member-name-link">probitHighPrecision</a><wbr>(double&nbsp;d)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">This is the same as <a href="#probit(double)"><code>probit(double)</code></a>,
 except that it performs an additional step of post-processing to
 bring the result even closer to the normal distribution.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#probitI(int)" class="member-name-link">probitI</a><wbr>(int&nbsp;i)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">A single-precision probit() approximation that takes any int and returns an
 approximately-Gaussian-distributed float between -9.082295 and 9.082295 .</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#probitL(long)" class="member-name-link">probitL</a><wbr>(long&nbsp;l)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">A double-precision probit() approximation that takes any long and returns an
 approximately-Gaussian-distributed double between -26.48372928592822 and 26.48372928592822 .</div>
</div>
</div>
</div>
</div>
<div class="inherited-list">
<h3 id="methods-inherited-from-class-java.lang.Object">Methods inherited from class&nbsp;java.lang.<a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></h3>
<code><a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Object.html#clone()" title="class or interface in java.lang" class="external-link">clone</a>, <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)" title="class or interface in java.lang" class="external-link">equals</a>, <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Object.html#finalize()" title="class or interface in java.lang" class="external-link">finalize</a>, <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Object.html#getClass()" title="class or interface in java.lang" class="external-link">getClass</a>, <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Object.html#hashCode()" title="class or interface in java.lang" class="external-link">hashCode</a>, <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Object.html#notify()" title="class or interface in java.lang" class="external-link">notify</a>, <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Object.html#notifyAll()" title="class or interface in java.lang" class="external-link">notifyAll</a>, <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Object.html#toString()" title="class or interface in java.lang" class="external-link">toString</a>, <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Object.html#wait()" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Object.html#wait(long)" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Object.html#wait(long,int)" title="class or interface in java.lang" class="external-link">wait</a></code></div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method-detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="probitF(float)">
<h3>probitF</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float</span>&nbsp;<span class="element-name">probitF</span><wbr><span class="parameters">(float&nbsp;p)</span></div>
<div class="block">A single-precision probit() approximation that takes a float between 0 and 1 inclusive and returns an
 approximately-Gaussian-distributed float between -9.082295 and 9.082295 .
 The function maps the lowest inputs to the most negative outputs, the highest inputs to the most
 positive outputs, and inputs near 0.5 to outputs near 0.
 <a href="https://www.researchgate.net/publication/46462650_A_New_Approximation_to_the_Normal_Distribution_Quantile_Function">Uses this algorithm by Paul Voutier</a>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>p</code> - should be between 0 and 1, inclusive.</dd>
<dt>Returns:</dt>
<dd>an approximately-Gaussian-distributed float between -9.082295 and 9.082295</dd>
<dt>See Also:</dt>
<dd>
<ul class="tag-list-long">
<li><a href="https://en.wikipedia.org/wiki/Probit_function">Wikipedia has a page on the probit function.</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="probitD(double)">
<h3>probitD</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="element-name">probitD</span><wbr><span class="parameters">(double&nbsp;p)</span></div>
<div class="block">A double-precision probit() approximation that takes a double between 0 and 1 inclusive and returns an
 approximately-Gaussian-distributed double between -26.48372928592822 and 26.48372928592822 .
 The function maps the lowest inputs to the most negative outputs, the highest inputs to the most
 positive outputs, and inputs near 0.5 to outputs near 0.
 <a href="https://www.researchgate.net/publication/46462650_A_New_Approximation_to_the_Normal_Distribution_Quantile_Function">Uses this algorithm by Paul Voutier</a>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>p</code> - should be between 0 and 1, inclusive.</dd>
<dt>Returns:</dt>
<dd>an approximately-Gaussian-distributed double between -26.48372928592822 and 26.48372928592822</dd>
<dt>See Also:</dt>
<dd>
<ul class="tag-list-long">
<li><a href="https://en.wikipedia.org/wiki/Probit_function">Wikipedia has a page on the probit function.</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="probitI(int)">
<h3>probitI</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float</span>&nbsp;<span class="element-name">probitI</span><wbr><span class="parameters">(int&nbsp;i)</span></div>
<div class="block">A single-precision probit() approximation that takes any int and returns an
 approximately-Gaussian-distributed float between -9.082295 and 9.082295 .
 The function maps the most negative inputs to the most negative outputs, the most positive inputs to the most
 positive outputs, and inputs near 0 to outputs near 0.
 <a href="https://www.researchgate.net/publication/46462650_A_New_Approximation_to_the_Normal_Distribution_Quantile_Function">Uses this algorithm by Paul Voutier</a>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>i</code> - may be any int, though very close ints will not produce different results</dd>
<dt>Returns:</dt>
<dd>an approximately-Gaussian-distributed float between -9.082295 and 9.082295</dd>
<dt>See Also:</dt>
<dd>
<ul class="tag-list-long">
<li><a href="https://en.wikipedia.org/wiki/Probit_function">Wikipedia has a page on the probit function.</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="probitL(long)">
<h3>probitL</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="element-name">probitL</span><wbr><span class="parameters">(long&nbsp;l)</span></div>
<div class="block">A double-precision probit() approximation that takes any long and returns an
 approximately-Gaussian-distributed double between -26.48372928592822 and 26.48372928592822 .
 The function maps the most negative inputs to the most negative outputs, the most positive inputs to the most
 positive outputs, and inputs near 0 to outputs near 0.
 <a href="https://www.researchgate.net/publication/46462650_A_New_Approximation_to_the_Normal_Distribution_Quantile_Function">Uses this algorithm by Paul Voutier</a>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>l</code> - may be any long, though very close longs will not produce different results</dd>
<dt>Returns:</dt>
<dd>an approximately-Gaussian-distributed double between -26.48372928592822 and 26.48372928592822</dd>
<dt>See Also:</dt>
<dd>
<ul class="tag-list-long">
<li><a href="https://en.wikipedia.org/wiki/Probit_function">Wikipedia has a page on the probit function.</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="probit(double)">
<h3>probit</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="element-name">probit</span><wbr><span class="parameters">(double&nbsp;d)</span></div>
<div class="block">A way of taking a double in the (0.0, 1.0) range and mapping it to a Gaussian or normal distribution, so high
 inputs correspond to high outputs, and similarly for the low range. This is centered on 0.0 and its standard
 deviation seems to be 1.0 (the same as <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/Random.html#nextGaussian()" title="class or interface in java.util" class="external-link"><code>Random.nextGaussian()</code></a>). If this is given an input of 0.0
 or less, it returns -8.375, which is slightly less than the result when given <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Double.html#MIN_VALUE" title="class or interface in java.lang" class="external-link"><code>Double.MIN_VALUE</code></a>. If it is
 given an input of 1.0 or more, it returns 8.375, which is significantly larger than the result when given the
 largest double less than 1.0 (this value is further from 1.0 than <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Double.html#MIN_VALUE" title="class or interface in java.lang" class="external-link"><code>Double.MIN_VALUE</code></a> is from 0.0). If
 given <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Double.html#NaN" title="class or interface in java.lang" class="external-link"><code>Double.NaN</code></a>, it returns whatever <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Math.html#copySign(double,double)" title="class or interface in java.lang" class="external-link"><code>Math.copySign(double, double)</code></a> returns for the arguments
 <code>8.375, Double.NaN</code>, which is implementation-dependent.
 <br>
 This uses an algorithm by Peter John Acklam, as implemented by Sherali Karimov.
 <a href="https://web.archive.org/web/20150910002142/http://home.online.no/~pjacklam/notes/invnorm/impl/karimov/StatUtil.java">Original source</a>.
 <a href="https://web.archive.org/web/20151030215612/http://home.online.no/~pjacklam/notes/invnorm/">Information on the algorithm</a>.
 <a href="https://en.wikipedia.org/wiki/Probit_function">Wikipedia's page on the probit function</a> may help, but
 is more likely to just be confusing.
 <br>
 Acklam's algorithm and Karimov's implementation are both competitive on speed with the Box-Muller Transform and
 Marsaglia's Polar Method, but slower than Ziggurat and the <a href="#probitD(double)"><code>probitD(double)</code></a> method here. This isn't quite
 as precise as Box-Muller or Marsaglia Polar, and can't produce as extreme min and max results in the extreme
 cases they should appear. If given a typical uniform random <code>double</code> that's exclusive on 1.0, it won't
 produce a result higher than
 <code>8.209536145151493</code>, and will only produce results of at least <code>-8.209536145151493</code> if 0.0 is
 excluded from the inputs (if 0.0 is an input, the result is <code>-8.375</code>). This requires a fair amount of
 floating-point multiplication and one division for all <code>d</code> where it is between 0 and 1 exclusive, but
 roughly 1/20 of the time it need a <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Math.html#sqrt(double)" title="class or interface in java.lang" class="external-link"><code>Math.sqrt(double)</code></a> and <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Math.html#log(double)" title="class or interface in java.lang" class="external-link"><code>Math.log(double)</code></a> as well.
 <br>
 This can be used both as an optimization for generating Gaussian random values, and as a way of generating
 Gaussian values that match a pattern present in the inputs (which you could have by using a sub-random sequence
 as the input, such as those produced by a van der Corput, Halton, Sobol or R2 sequence). Most methods of generating
 Gaussian values (e.g. Box-Muller and Marsaglia polar) do not have any way to preserve a particular pattern. Note
 that if you don't need to preserve patterns in input, then either the Ziggurat method (which is available via the
 <a href="#normal(long)"><code>normal(long)</code></a> method) or the Marsaglia polar method (which is the default in the JDK Random class) will
 perform better in each one's optimal circumstances. The <a href="#probitD(double)"><code>probitD(double)</code></a> method here (using a faster
 probit algorithm) preserves patterns in input (given the same range of double), and should usually be preferred
 to this older method. The <a href="#probitF(float)"><code>probitF(float)</code></a> method provides a float-to-float variant, and others take int
 or long arguments and return floats or doubles. You could also use <a href="#linearNormal(long)"><code>linearNormal(long)</code></a> to take long
 arguments and return doubles, but it loses a lot of accuracy.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>d</code> - should be between 0 and 1, exclusive, but other values are tolerated</dd>
<dt>Returns:</dt>
<dd>a normal-distributed double centered on 0.0; all results will be between -8.375 and 8.375, both inclusive</dd>
<dt>See Also:</dt>
<dd>
<ul class="tag-list-long">
<li><a href="#probitHighPrecision(double)"><code>There is a higher-precision, slower variant on this method.</code></a></li>
<li><a href="#probitD(double)"><code>There is a more-recent approximation that should be faster and more precise than this one.</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="probitHighPrecision(double)">
<h3>probitHighPrecision</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="element-name">probitHighPrecision</span><wbr><span class="parameters">(double&nbsp;d)</span></div>
<div class="block">This is the same as <a href="#probit(double)"><code>probit(double)</code></a>,
 except that it performs an additional step of post-processing to
 bring the result even closer to the normal distribution.
 It also produces normal-distributed doubles (with standard deviation 1.0)
 given inputs between 0.0 and 1.0, exclusive.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>d</code> - should be between <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Double.html#MIN_NORMAL" title="class or interface in java.lang" class="external-link"><code>Double.MIN_NORMAL</code></a>, inclusive, and 1, exclusive; subnormal values may return NaN</dd>
<dt>Returns:</dt>
<dd>a normal-distributed double centered on 0.0</dd>
<dt>See Also:</dt>
<dd>
<ul class="tag-list-long">
<li><a href="#probit(double)"><code>There is a lower-precision, faster variant on this method, which this uses internally.</code></a></li>
<li><a href="#probitD(double)"><code>A more-recently-published approximation that should be faster, and may have comparable quality</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="linearNormal(long)">
<h3>linearNormal</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="element-name">linearNormal</span><wbr><span class="parameters">(long&nbsp;n)</span></div>
<div class="block">This is an alias for <a href="#probitL(long)"><code>probitL(long)</code></a>; see its docs for details.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>n</code> - may be any long, though very close longs will not produce different results</dd>
<dt>Returns:</dt>
<dd>an approximately-Gaussian-distributed double between -26.48372928592822 and 26.48372928592822</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="linearNormalF(int)">
<h3>linearNormalF</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float</span>&nbsp;<span class="element-name">linearNormalF</span><wbr><span class="parameters">(int&nbsp;n)</span></div>
<div class="block">This is an alias for <a href="#probitI(int)"><code>probitI(int)</code></a>; see its docs for details.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>n</code> - may be any int, though very close ints will not produce different results</dd>
<dt>Returns:</dt>
<dd>an approximately-Gaussian-distributed float between -9.082295 and 9.082295</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="normal(long)">
<h3>normal</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="element-name">normal</span><wbr><span class="parameters">(long&nbsp;state)</span></div>
<div class="block">Given a long where all bits are sufficiently (independently) random, this produces a normal-distributed
 (Gaussian) variable as if by a normal distribution with mean (mu) 0.0 and standard deviation (sigma) 1.0.
 This uses the Ziggurat algorithm, and takes one <code>long</code> input to produce one <code>double</code> value.
 Note that no additive counters are considered sufficiently random for this, and linear congruential generators
 might not be random enough either if they return the low-order bits without changes.
 Patterns between different <code>state</code> values provided to this will generally not be preserved in the
 output, but this may not be true all the time for patterns on all bits.
 <br>
 The range this can produce is at least from -7.6719775673883905 to 7.183851151080583, and is almost certainly larger
 (only 4 billion distinct inputs were tested, and there are over 18 quintillion inputs possible).
 <br>
 From <a href="https://github.com/camel-cdr/cauldron/blob/7d5328441b1a1bc8143f627aebafe58b29531cb9/cauldron/random.h#L2013-L2265">Cauldron</a>,
 MIT-licensed. This in turn is based on Doornik's form of the Ziggurat method:
 <br>
      Doornik, Jurgen A (2005):
      "An improved ziggurat method to generate normal random samples."
      University of Oxford: 77.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>state</code> - a long that should be sufficiently random; quasi-random longs may not be enough</dd>
<dt>Returns:</dt>
<dd>a normal-distributed double with mean (mu) 0.0 and standard deviation (sigma) 1.0</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="normalF(int)">
<h3>normalF</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float</span>&nbsp;<span class="element-name">normalF</span><wbr><span class="parameters">(int&nbsp;state)</span></div>
<div class="block">Given an int where all bits are sufficiently (independently) random, this produces a normal-distributed float
 (Gaussian) variable as if by a normal distribution with mean (mu) 0.0 and standard deviation (sigma) 1.0.
 This uses the Ziggurat algorithm, and takes one <code>int</code> input to produce one <code>float</code> value.
 Note that no additive counters are considered sufficiently random for this, and linear congruential generators
 might not be random enough either if they return the low-order bits without changes.
 Patterns between different <code>state</code> values provided to this will generally not be preserved in the
 output, but this may not be true all the time for patterns on all bits.
 <br>
 The range this can produce is from -6.127281f to 6.158781f, both inclusive. This was tested exhaustively.
 <br>
 From <a href="https://github.com/camel-cdr/cauldron/blob/7d5328441b1a1bc8143f627aebafe58b29531cb9/cauldron/random.h#L2013-L2265">Cauldron</a>,
 MIT-licensed. This in turn is based on Doornik's form of the Ziggurat method:
 <br>
      Doornik, Jurgen A (2005):
      "An improved ziggurat method to generate normal random samples."
      University of Oxford: 77.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>state</code> - an int that should be sufficiently random; quasi-random longs may not be enough</dd>
<dt>Returns:</dt>
<dd>a normal-distributed float with mean (mu) 0.0 and standard deviation (sigma) 1.0</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
</div>
</div>
</body>
</html>

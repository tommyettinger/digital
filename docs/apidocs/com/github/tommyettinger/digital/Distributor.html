<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (17) -->
<title>Distributor (digital 0.5.2 API)</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="description" content="declaration: package: com.github.tommyettinger.digital, class: Distributor">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
<script type="text/javascript" src="../../../../script-dir/jquery-3.6.1.min.js"></script>
<script type="text/javascript" src="../../../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var evenRowColor = "even-row-color";
var oddRowColor = "odd-row-color";
var tableTab = "table-tab";
var activeTableTab = "active-table-tab";
var pathtoroot = "../../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar-top">
<div class="skip-nav"><a href="#skip-navbar-top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar-top-firstrow" class="nav-list" title="Navigation">
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html#class">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method-summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method-detail">Method</a></li>
</ul>
</div>
<div class="nav-list-search"><label for="search-input">SEARCH:</label>
<input type="text" id="search-input" value="search" disabled="disabled">
<input type="reset" id="reset-button" value="reset" disabled="disabled">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip-navbar-top"></span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">com.github.tommyettinger.digital</a></div>
<h1 title="Class Distributor" class="title">Class Distributor</h1>
</div>
<div class="inheritance" title="Inheritance Tree"><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">java.lang.Object</a>
<div class="inheritance">com.github.tommyettinger.digital.Distributor</div>
</div>
<section class="class-description" id="class-description">
<hr>
<div class="type-signature"><span class="modifiers">public final class </span><span class="element-name type-name-label">Distributor</span>
<span class="extends-implements">extends <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></span></div>
<div class="block">Different methods for distributing input <code>long</code> or <code>double</code> values from a given domain into specific
 distributions, such as the normal distribution. <a href="#probit(double)"><code>probit(double)</code></a> and <a href="#probitHighPrecision(double)"><code>probitHighPrecision(double)</code></a> take
 a double in the 0.0 to 1.0 range (typically exclusive, but not required to be), and produce a normal-distributed
 double centered on 0.0 with standard deviation 1.0 . <a href="#normal(long)"><code>normal(long)</code></a> takes a long in the entire range of
 possible long values, and also produces a double centered on 0.0 with standard deviation 1.0 . Similarly,
 <a href="#normalF(int)"><code>normalF(int)</code></a> takes an int in the entire range of possible int values, and produces a float centered on 0f
 with standard deviation 1f. All of these ways will preserve patterns in the input, so inputs close to the lowest
 possible input (0.0 for probit(), <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Long.html#MIN_VALUE" title="class or interface in java.lang" class="external-link"><code>Long.MIN_VALUE</code></a> for normal(), <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Integer.html#MIN_VALUE" title="class or interface in java.lang" class="external-link"><code>Integer.MIN_VALUE</code></a> for normalF()) will
 produce the lowest possible output (-8.375 for probit(), normal(), and normalF()),
 and similarly for the highest possible inputs producing the highest possible outputs.</div>
</section>
<section class="summary">
<ul class="summary-list">
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method-summary">
<h2>Method Summary</h2>
<div id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button id="method-summary-table-tab0" role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table', 3)" class="active-table-tab">All Methods</button><button id="method-summary-table-tab1" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab1', 3)" class="table-tab">Static Methods</button><button id="method-summary-table-tab4" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab4', 3)" class="table-tab">Concrete Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel">
<div class="summary-table three-column-summary" aria-labelledby="method-summary-table-tab0">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Method</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#normal(long)" class="member-name-link">normal</a><wbr>(long&nbsp;n)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Given any <code>long</code> as input, this maps the full range of non-negative long values to much of the non-negative
 half of the range of the normal distribution with standard deviation 1.0, and similarly maps all negative long
 values to their equivalent-magnitude non-negative counterparts.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static float</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#normalF(int)" class="member-name-link">normalF</a><wbr>(int&nbsp;n)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Given any <code>int</code> as input, this maps the full range of non-negative int values to much of the non-negative
 half of the range of the normal distribution with standard deviation 1f, and similarly maps all negative int
 values to their equivalent-magnitude non-negative counterparts.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#probit(double)" class="member-name-link">probit</a><wbr>(double&nbsp;d)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">A way of taking a double in the (0.0, 1.0) range and mapping it to a Gaussian or normal distribution, so high
 inputs correspond to high outputs, and similarly for the low range.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static double</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#probitHighPrecision(double)" class="member-name-link">probitHighPrecision</a><wbr>(double&nbsp;d)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">This is the same as <a href="#probit(double)"><code>probit(double)</code></a>,
 except that it performs an additional step of post-processing to
 bring the result even closer to the normal distribution.</div>
</div>
</div>
</div>
</div>
<div class="inherited-list">
<h3 id="methods-inherited-from-class-java.lang.Object">Methods inherited from class&nbsp;java.lang.<a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></h3>
<code><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#clone()" title="class or interface in java.lang" class="external-link">clone</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)" title="class or interface in java.lang" class="external-link">equals</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#finalize()" title="class or interface in java.lang" class="external-link">finalize</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#getClass()" title="class or interface in java.lang" class="external-link">getClass</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#hashCode()" title="class or interface in java.lang" class="external-link">hashCode</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#notify()" title="class or interface in java.lang" class="external-link">notify</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#notifyAll()" title="class or interface in java.lang" class="external-link">notifyAll</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#toString()" title="class or interface in java.lang" class="external-link">toString</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#wait()" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#wait(long)" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#wait(long,int)" title="class or interface in java.lang" class="external-link">wait</a></code></div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method-detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="probit(double)">
<h3>probit</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="element-name">probit</span><wbr><span class="parameters">(double&nbsp;d)</span></div>
<div class="block">A way of taking a double in the (0.0, 1.0) range and mapping it to a Gaussian or normal distribution, so high
 inputs correspond to high outputs, and similarly for the low range. This is centered on 0.0 and its standard
 deviation seems to be 1.0 (the same as <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Random.html#nextGaussian()" title="class or interface in java.util" class="external-link"><code>Random.nextGaussian()</code></a>). If this is given an input of 0.0
 or less, it returns -8.375, which is slightly less than the result when given <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Double.html#MIN_VALUE" title="class or interface in java.lang" class="external-link"><code>Double.MIN_VALUE</code></a>. If it is
 given an input of 1.0 or more, it returns 8.375, which is significantly larger than the result when given the
 largest double less than 1.0 (this value is further from 1.0 than <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Double.html#MIN_VALUE" title="class or interface in java.lang" class="external-link"><code>Double.MIN_VALUE</code></a> is from 0.0). If
 given <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Double.html#NaN" title="class or interface in java.lang" class="external-link"><code>Double.NaN</code></a>, it returns whatever <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Math.html#copySign(double,double)" title="class or interface in java.lang" class="external-link"><code>Math.copySign(double, double)</code></a> returns for the arguments
 <code>8.375, Double.NaN</code>, which is implementation-dependent.
 <br>
 This uses an algorithm by Peter John Acklam, as implemented by Sherali Karimov.
 <a href="https://web.archive.org/web/20150910002142/http://home.online.no/~pjacklam/notes/invnorm/impl/karimov/StatUtil.java">Original source</a>.
 <a href="https://web.archive.org/web/20151030215612/http://home.online.no/~pjacklam/notes/invnorm/">Information on the algorithm</a>.
 <a href="https://en.wikipedia.org/wiki/Probit_function">Wikipedia's page on the probit function</a> may help, but
 is more likely to just be confusing.
 <br>
 Acklam's algorithm and Karimov's implementation are both competitive on speed with the Box-Muller Transform and
 Marsaglia's Polar Method, but slower than Ziggurat and the <a href="#normal(long)"><code>normal(long)</code></a> method here. This isn't quite
 as precise as Box-Muller or Marsaglia Polar, and can't produce as extreme min and max results in the extreme
 cases they should appear. If given a typical uniform random <code>double</code> that's exclusive on 1.0, it won't
 produce a result higher than
 <code>8.209536145151493</code>, and will only produce results of at least <code>-8.209536145151493</code> if 0.0 is
 excluded from the inputs (if 0.0 is an input, the result is <code>-8.375</code>). This requires a fair amount of
 floating-point multiplication and one division for all <code>d</code> where it is between 0 and 1 exclusive, but
 roughly 1/20 of the time it need a <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Math.html#sqrt(double)" title="class or interface in java.lang" class="external-link"><code>Math.sqrt(double)</code></a> and <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Math.html#log(double)" title="class or interface in java.lang" class="external-link"><code>Math.log(double)</code></a> as well.
 <br>
 This can be used both as an optimization for generating Gaussian random values, and as a way of generating
 Gaussian values that match a pattern present in the inputs (which you could have by using a sub-random sequence
 as the input, such as those produced by a van der Corput, Halton, Sobol or R2 sequence). Most methods of generating
 Gaussian values (e.g. Box-Muller and Marsaglia polar) do not have any way to preserve a particular pattern. Note
 that if you don't need to preserve patterns in input, then either the Ziggurat method (which is available and the
 default in the juniper library for pseudo-random generation) or the Marsaglia polar method (which is the default
 in the JDK Random class) will perform better in each one's optimal circumstances. The <a href="#normal(long)"><code>normal(long)</code></a>
 method here (using the Linnormal algorithm) both preserves patterns in input (given a <code>long</code>) and is faster
 than Ziggurat, making it the quickest here, though at some cost to precision.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>d</code> - should be between 0 and 1, exclusive, but other values are tolerated</dd>
<dt>Returns:</dt>
<dd>a normal-distributed double centered on 0.0; all results will be between -8.375 and 8.375, both inclusive</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="#probitHighPrecision(double)"><code>There is a higher-precision, slower variant on this method.</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="probitHighPrecision(double)">
<h3>probitHighPrecision</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="element-name">probitHighPrecision</span><wbr><span class="parameters">(double&nbsp;d)</span></div>
<div class="block">This is the same as <a href="#probit(double)"><code>probit(double)</code></a>,
 except that it performs an additional step of post-processing to
 bring the result even closer to the normal distribution.
 It also produces normal-distributed doubles (with standard deviation 1.0)
 given inputs between 0.0 and 1.0, exclusive.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>d</code> - should be between <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Double.html#MIN_NORMAL" title="class or interface in java.lang" class="external-link"><code>Double.MIN_NORMAL</code></a>, inclusive, and 1, exclusive; subnormal values may return NaN</dd>
<dt>Returns:</dt>
<dd>a normal-distributed double centered on 0.0</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="#probit(double)"><code>There is a lower-precision, faster variant on this method, which this uses internally.</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="normal(long)">
<h3>normal</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">double</span>&nbsp;<span class="element-name">normal</span><wbr><span class="parameters">(long&nbsp;n)</span></div>
<div class="block">Given any <code>long</code> as input, this maps the full range of non-negative long values to much of the non-negative
 half of the range of the normal distribution with standard deviation 1.0, and similarly maps all negative long
 values to their equivalent-magnitude non-negative counterparts. Notably, an input of 0 will map to <code>0.0</code>,
 an input of -1 will map to <code>-0.0</code>, and inputs of <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Long.html#MIN_VALUE" title="class or interface in java.lang" class="external-link"><code>Long.MIN_VALUE</code></a> and  <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Long.html#MAX_VALUE" title="class or interface in java.lang" class="external-link"><code>Long.MAX_VALUE</code></a> will
 map to <code>-8.375</code> and <code>8.375</code>, respectively. If you only pass this small
 sequential inputs, there may be no detectable difference between some outputs. This is meant to be given inputs
 with large differences (at least millions) if very different outputs are desired.
 <br>
 The algorithm here can be called Linnormal; it is comparatively quite simple, and mostly relies on lookup from a
 precomputed table of results of <a href="#probitHighPrecision(double)"><code>probitHighPrecision(double)</code></a>, followed by linear interpolation. Values in
 the "trail" of the normal distribution, that is, those produced by long values in the uppermost 1/2048 of all
 values or the lowermost 1/2048 of all values, are computed slightly differently. Where the other parts of the
 distribution use the bottom 53 bits to make an interpolant between 0.0 and 1.0 and use it verbatim, values in the
 trail do all that and then square that interpolant, before going through the same type of interpolation.
 <br>
 This is like the "Ziggurat algorithm" to make normal-distributed doubles, but this preserves patterns in the
 input. Uses a large table of the results of <a href="#probitHighPrecision(double)"><code>probitHighPrecision(double)</code></a>, and interpolates between
 them using linear interpolation. This tends to be faster than Ziggurat at generating normal-distributed values,
 though it probably has slightly worse quality. Since Ziggurat is already much faster than other common methods,
 such as the Box-Muller Method, <a href="#probit(double)"><code>probit(double)</code></a> function, or the Marsaglia Polar Method (which Java itself
 uses), this being faster than Ziggurat is a good thing. All methods of generating normal-distributed variables
 while preserving input patterns are approximations, and this is slightly less accurate than some ways (but better
 than the simplest ways, like just summing many random variables and re-centering around 0).</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>n</code> - any long; input patterns will be preserved</dd>
<dt>Returns:</dt>
<dd>a normal-distributed double, matching patterns in <code>n</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="normalF(int)">
<h3>normalF</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">float</span>&nbsp;<span class="element-name">normalF</span><wbr><span class="parameters">(int&nbsp;n)</span></div>
<div class="block">Given any <code>int</code> as input, this maps the full range of non-negative int values to much of the non-negative
 half of the range of the normal distribution with standard deviation 1f, and similarly maps all negative int
 values to their equivalent-magnitude non-negative counterparts. Notably, an input of 0 will map to <code>0f</code>,
 an input of -1 will map to <code>-0f</code>, and inputs of <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Integer.html#MIN_VALUE" title="class or interface in java.lang" class="external-link"><code>Integer.MIN_VALUE</code></a> and <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Integer.html#MAX_VALUE" title="class or interface in java.lang" class="external-link"><code>Integer.MAX_VALUE</code></a>
 will map to <code>-8.375f</code> and <code>8.375f</code>, respectively. If you only pass this small
 sequential inputs, there may be no detectable difference between some outputs. This is meant to be given inputs
 with large differences (at least millions) if very different outputs are desired.
 <br>
 The algorithm here can be called Linnormal; it is comparatively quite simple, and mostly relies on lookup from a
 precomputed table of results of <a href="#probitHighPrecision(double)"><code>probitHighPrecision(double)</code></a>, followed by linear interpolation. Values in
 the "trail" of the normal distribution, that is, those produced by int values in the uppermost 1/2048 of all
 values or the lowermost 1/2048 of all values, are computed slightly differently. Where the other parts of the
 distribution use the bottom 53 bits to make an interpolant between 0.0 and 1.0 and use it verbatim, values in the
 trail do all that and then square that interpolant, before going through the same type of interpolation.
 <br>
 This is like the "Ziggurat algorithm" to make normal-distributed doubles, but this preserves patterns in the
 input. Uses a large table of the results of <a href="#probitHighPrecision(double)"><code>probitHighPrecision(double)</code></a>, and interpolates between
 them using linear interpolation. This tends to be faster than Ziggurat at generating normal-distributed values,
 though it probably has slightly worse quality. Since Ziggurat is already much faster than other common methods,
 such as the Box-Muller Method, <a href="#probit(double)"><code>probit(double)</code></a> function, or the Marsaglia Polar Method (which Java itself
 uses), this being faster than Ziggurat is a good thing. All methods of generating normal-distributed variables
 while preserving input patterns are approximations, and this is slightly less accurate than some ways (but better
 than the simplest ways, like just summing many random variables and re-centering around 0).</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>n</code> - any int; input patterns will be preserved</dd>
<dt>Returns:</dt>
<dd>a normal-distributed float, matching patterns in <code>n</code></dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
</div>
</div>
</body>
</html>
